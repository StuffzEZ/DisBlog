name: DisBlog

on:
  discussion:
    types: [created, edited]

permissions:
  contents: write
  discussions: read

jobs:
  create-or-update-post:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
        
      - name: Extract Discussion Data and Convert Markdown
        id: discussion
        run: |
          # Extract data from the webhook payload
          title=$(echo '${{ github.event.discussion.title }}' | sed 's/"/\\"/g')
          number="${{ github.event.discussion.number }}"
          
          # Create a temporary markdown file using a here document to avoid shell interpretation
          cat << 'MARKDOWN_EOF' > temp_content.md
          ${{ github.event.discussion.body }}
          MARKDOWN_EOF
          
          # Pre-process the markdown to escape problematic HTML tags that might break parsing
          # This converts <script> to &lt;script&gt; etc. to prevent markdown parser issues
          sed -i 's/<script>/\&lt;script\&gt;/g' temp_content.md
          sed -i 's/<\/script>/\&lt;\/script\&gt;/g' temp_content.md
          sed -i 's/<style>/\&lt;style\&gt;/g' temp_content.md
          sed -i 's/<\/style>/\&lt;\/style\&gt;/g' temp_content.md
          
          # Install marked (a popular markdown parser)
          npm install -g marked
          
          # Configure marked to be more lenient and handle mixed content better
          # Convert markdown to HTML
          html_content=$(marked --gfm --breaks temp_content.md)
          
          # Clean up
          rm temp_content.md
          
          # Save outputs (need to handle multiline content properly)
          echo "title=$title" >> $GITHUB_OUTPUT
          echo "number=$number" >> $GITHUB_OUTPUT
          
          # For multiline content, use EOF delimiter
          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$html_content" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
            
      - name: Create or update post from template
        env:
          GIST_URL: ${{ vars.TEMPLATE_GIST_URL }}  # You'll need to set this as a repository variable
          BLOG_NAME: ${{ vars.BLOG_NAME }}  # You'll need to set this as a repository variable
        run: |
          # Create posts directory if it doesn't exist
          mkdir -p posts
          
          post_file="posts/${{ steps.discussion.outputs.number }}.html"
          
          # Check if this is an edit (post file already exists)
          if [ -f "$post_file" ]; then
            echo "Post exists - updating existing post"
            
            # Get the discussion data from the previous step
            title="${{ steps.discussion.outputs.title }}"
            number="${{ steps.discussion.outputs.number }}"
            
            # Save the HTML content to a temporary file for safer handling
            cat << 'CONTENT_EOF' > temp_html_content.html
          ${{ steps.discussion.outputs.content }}
          CONTENT_EOF
            
            # Use Python to update specific elements in the existing HTML file
            python3 << 'PYTHON_EOF'
          import re
          
          def replace_element_content(html, element_id, new_content):
              """Replace content inside an element with specific id"""
              # First, find the opening tag and determine the element type
              opening_pattern = r'<(\w+)([^>]*id=["\']' + re.escape(element_id) + r'["\'][^>]*)>'
              opening_match = re.search(opening_pattern, html)
              
              if not opening_match:
                  print(f"Warning: Element with id '{element_id}' not found")
                  return html
              
              element_type = opening_match.group(1)  # e.g., 'div', 'h1', etc.
              
              # Create pattern to match the complete element with its specific closing tag
              pattern = r'(<' + element_type + r'[^>]*id=["\']' + re.escape(element_id) + r'["\'][^>]*>)(.*?)(<\/' + element_type + r'>)'
              
              def replacer(match):
                  opening_tag = match.group(1)
                  closing_tag = match.group(3)
                  return opening_tag + new_content + closing_tag
              
              result = re.sub(pattern, replacer, html, flags=re.DOTALL)
              return result
          
          # Read the existing HTML file from the posts directory
          with open('posts/${{ steps.discussion.outputs.number }}.html', 'r') as f:
              existing_html = f.read()
          
          # Read the new content
          with open('temp_html_content.html', 'r') as f:
              new_content = f.read().strip()
          
          # Update the title element with id="title-forpost"
          new_title = '''${{ steps.discussion.outputs.title }}'''
          existing_html = replace_element_content(existing_html, 'title-forpost', new_title)
          
          # Update the content element with id="maincontent-forpost"
          existing_html = replace_element_content(existing_html, 'maincontent-forpost', new_content)
          
          # Write the updated file back to the posts directory
          with open('posts/${{ steps.discussion.outputs.number }}.html', 'w') as f:
              f.write(existing_html)
          PYTHON_EOF
            
            # Clean up temporary files
            rm temp_html_content.html
            
          else
            echo "New post - creating from template"
            
            # Download the template from the gist
            curl -s "$GIST_URL" -o template.html
            
            # Read the template file
            template_content=$(cat template.html)
            
            # Get the discussion data from the previous step
            title="${{ steps.discussion.outputs.title }}"
            number="${{ steps.discussion.outputs.number }}"
            
            # Get repository info
            repo_path="${{ github.repository }}"
            blog_name="$BLOG_NAME"
            
            # Escape special characters for sed (more reliable approach)
            escaped_title=$(printf '%s\n' "$title" | sed 's/[/]/\\&/g' | sed 's/&/\\&/g')
            escaped_blog_name=$(printf '%s\n' "$blog_name" | sed 's/[/]/\\&/g' | sed 's/&/\\&/g')
            escaped_repo_path=$(printf '%s\n' "$repo_path" | sed 's/[/]/\\&/g' | sed 's/&/\\&/g')
            
            # Replace placeholders in the template step by step (except content)
            echo "$template_content" | sed "s|{{ discussion\.title }}|$escaped_title|g" > temp_template.html
            
            # Replace the discussion.id placeholder with the discussion number
            sed "s|{{ discussion\.id }}|$number|g" temp_template.html > temp_template2.html
            
            # Replace blog.name with the blog name from variables
            sed "s|{{ blog\.name }}|$escaped_blog_name|g" temp_template2.html > temp_template3.html
            
            # Replace repo.path with the repository path (owner/repo)
            sed "s|{{ repo\.path }}|$escaped_repo_path|g" temp_template3.html > temp_template4.html
            
            # Save the HTML content to a temporary file for safer handling
            cat << 'CONTENT_EOF' > temp_html_content.html
          ${{ steps.discussion.outputs.content }}
          CONTENT_EOF
            
            # Use Python to replace the content placeholder (more reliable for complex HTML)
            python3 << 'PYTHON_EOF'
          import re
          
          # Read the template
          with open('temp_template4.html', 'r') as f:
              template = f.read()
          
          # Read the HTML content
          with open('temp_html_content.html', 'r') as f:
              content = f.read()
          
          # Replace the content placeholder
          final_html = re.sub(r'\{\{\s*discussion\.content\s*\}\}', content, template)
          
          # Write the final file
          with open('posts/${{ steps.discussion.outputs.number }}.html', 'w') as f:
              f.write(final_html)
          PYTHON_EOF
            
            # Clean up temporary files
            rm template.html temp_template.html temp_template2.html temp_template3.html temp_template4.html temp_html_content.html
          fi
          
      - name: Commit and push changes
        run: |
          git config --local user.email "disblog-bot@noreply.github.com"
          git config --local user.name "DisBlog Bot"
          
          # Check if this was an edit or new post
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git add posts/${{ steps.discussion.outputs.number }}.html
          
          # Determine if this is a new post or update based on git status
          if git diff --cached --name-only | grep -q "posts/${{ steps.discussion.outputs.number }}.html"; then
            if git ls-files --error-unmatch posts/${{ steps.discussion.outputs.number }}.html 2>/dev/null; then
              # File exists in git, this is an update
              git commit -m "[DISBLOG] ‚úèÔ∏è Update blog post from discussion #${{ steps.discussion.outputs.number }}: ${{ steps.discussion.outputs.title }}"
            else
              # File doesn't exist in git, this is new
              git commit -m "[DISBLOG] üìù Add blog post from discussion #${{ steps.discussion.outputs.number }}: ${{ steps.discussion.outputs.title }}"
            fi
          fi
          
          git push
